game.states.Light = State {
    function()
        params.LightEffect = {
            type = EParamType.String,
            required = false,
            default = "VFX_LightSources_GEN_Torch_A_01_0aee588d-ba2a-aa3b-a048-5fbc03779371",
            help = "VFX while item is on."
        }

        params.LightEffectBone = {
            type = EParamType.String,
            required = false,
            default = "Dummy_FX",
            help = "Bone on which the VFX is played."
        }

        params.GameplayLight = {type = EParamType.Bool,
            required = false,
            default = false,
            help = "Does the item cast a gameplay light, or is purely decorative?"
        }

        params.GameplayLightRadius = {
            type = EParamType.Number,
            required = false,
            default = 5.0,
            help = "Radius of gameplay light"
        }

        params.GameplayLightSharpness = {
            type = EParamType.Number,
            required = false,
            default = 0.1,
            help = "Sharpness of gameplay light"
        }

        params.GameplayLightOffsetFallback = {
            type = EParamType.Vector3,
            help = "Places the gameplay light at this position if the provided bone is not valid for the entity.",
            required = false,
            default = Vector3(0, 0, 0)
        }

        params.StartLit = {
            type = EParamType.Bool,
            required = false,
            default = true,
            help = "Does the item start lit?"
        }

        params.LightOnSound = {
            type = EParamType.String,
            required = false,
            default = "",
            help = "Sound played when this light is turned on."
        }

        params.LightOffSound = {
            type = EParamType.String,
            required = false,
            default = "",
            help = "Sound played when this light is turned off."
        }

        params.GameplayLightRadius = {
            type = EParamType.Number,
            required = false,
            default = 5.0,
            help = "Radius of gameplay light"
        }

        params.GameplayLightPointLightVerticalLimit = {
            type = EParamType.Number,
            required = false,
            default = 2.5,
            help = "Vertical limit of a point light that does not check line-of-sight"
        }

        inputs.TurnOn = {}
        inputs.TurnOff = {}
        inputs.Toggle = {}
        inputs.ChangeVFX = {}

        outputs.On = {help = "Light turned on"}
        outputs.Off = {help = "Light turned off"}

        nodes.VisualPreview = Proxy {
            game.states.VisualPreviewHelper,
            params = {
                PreviewEffect = params.LightEffect,
                PreviewEffectBone = params.LightEffectBone,
                StartActive = params.StartLit
            },
            inputs = {
                Activate = { outputs.On },
                Deactivate = { outputs.Off }
            }
        }

        local wasInitializedFact = "Cnst.Light.WasInitialized"
       
        helpers.SwitchScriptedLight = function(on)
            local wasLit = IsScriptedLightOn(me)
            
            if not wasLit and on then
                SwitchOnScriptedLight(me)
            elseif wasLit and not on then
                SwitchOffScriptedLight(me)
            end

            return wasLit ~= on
        end

        helpers.SwitchGameplayLight = function(on)
            local checkLOS = false
            local isSunlight = false
            SwitchGameplayLight(
                me, 
                on, 
                params.GameplayLightRadius, 
                checkLOS, 
                params.GameplayLightSharpness, 
                isSunlight, 
                params.GameplayLightOffsetFallback,
                params.GameplayLightPointLightVerticalLimit)
        end

        helpers.SwitchLight = function(on, source, silent)
            local sourceref = source and source.EntityRef or nil
            local changed = helpers.SwitchScriptedLight(on)
            
            if params.GameplayLight then
                helpers.SwitchGameplayLight(on)
            end
            
            if changed and not silent then
                if on then
                    TriggerOutput(outputs.On, sourceref, nil)
                else
                    TriggerOutput(outputs.Off, sourceref, nil)
                end
            end

            if changed then
                if on and params.LightOnSound ~= "" then
                    PlaySound(me, params.LightOnSound)
                elseif not on and params.LightOffSound ~= "" then
                    PlaySound(me, params.LightOffSound)
                end
            end
        end

        socketEvents.TurnOn = function(ev)
            local source = ev and ev.Object and Entity(ev.Object) or nil
            helpers.SwitchLight(true, source)
        end

        socketEvents.TurnOff = function(ev)
            local source = ev and ev.Object and Entity(ev.Object) or nil
            helpers.SwitchLight(false, source)
        end

        socketEvents.Toggle = function(ev)
            local source = ev and ev.Object and Entity(ev.Object) or nil
            helpers.SwitchLight(not IsScriptedLightOn(me), source)
        end

        socketEvents.ChangeVFX = function(ev)
            local newEffectName = ev.Param ~= "" and ev.Param or params.LightEffect
            if newEffectName ~= "" then
                local newEffect = PrepareEffect(newEffectName)
                UpdateScriptedLight(me, newEffect, params.LightEffectBone)
            end
        end

        self.OnLoaded = function()
            if params.LightEffect ~= "" then
                local effect = PrepareEffect(params.LightEffect)
                SetupScriptedLight(me, effect, params.LightEffectBone, params.StartLit)
            end

            -- Gameplay Lights do not persist, so we must either initialize according to the StartLit parameters
            -- (on the first initialization) or the persistent gameplay Lit state (on subsequent initializations).
            local wasInitialized = me.Blackboard.GetFact(wasInitializedFact) ~= nil
            local initGameplayLight = (not wasInitialized and params.StartLit) or (wasInitialized and IsScriptedLightOn(me))
            if initGameplayLight then
                helpers.SwitchGameplayLight(true)
            end
            me.Blackboard.SetFact(wasInitializedFact, 1)
        end
    end
    
}

game.states.Lamp = State {
    function()
        params.LightEffect = {
            type = EParamType.String,
            required = false,
            default = "VFX_LightSources_GEN_Torch_A_01_0aee588d-ba2a-aa3b-a048-5fbc03779371",
            help = "VFX while item is lit."
        }

        params.LightEffectBone = {
            type = EParamType.String,
            required = false,
            default = "",
            help = "Bone on which the VFX is played and the gameplay light is attached."
        }

        params.GameplayLight = {
            type = EParamType.Bool,
            required = false,
            default = false,
            help = "Does the item cast a gameplay light, or is purely decorative?"
        }

        params.GameplayLightRadius = {
            type = EParamType.Number,
            required = false,
            default = 5.0,
            help = "Radius of gameplay light"
        }

        params.GameplayLightSharpness = {
            type = EParamType.Number,
            required = false,
            default = 0.1,
            help = "Sharpness of gameplay light"
        }

        params.GameplayLightOffsetFallback = {
            type = EParamType.Vector3,
            help = "Places the gameplay light at this position if the provided bone is not valid for the entity.",
            required = false,
            default = Vector3(0, 0, 0)
        }

        params.StartLit = {
            type = EParamType.Bool,
            required = false,
            default = true,
            help = "Does the item start lit?"
        }

        params.LightOnSound = {
            type = EParamType.String,
            required = false,
            default = "",
            help = "Sound played when this light is turned on."
        }

        params.LightOffSound = {
            type = EParamType.String,
            required = false,
            default = "",
            help = "Sound played when this light is turned off."
        }

        params.GameplayLightPointLightVerticalLimit = {
            type = EParamType.Number,
            required = false,
            default = 2.5,
            help = "Vertical limit of a point light that does not check line-of-sight"
        }

        inputs.TurnOn = {}
        inputs.TurnOff = {}
        inputs.ChangeVFX = {}

        outputs.TurnOnInt = {internal = true}
        outputs.TurnOffInt = {internal = true}
        outputs.ToggleInt = {internal = true}
        outputs.ChangeVFXInt = { internal = true }

        outputs.On = {help = "Light turned on"}
        outputs.Off = {help = "Light turned off"}

        inputs.OnInt = {internal = true}
        inputs.OffInt = {internal = true}

        nodes.Light = Proxy {
            game.states.Light,
            params = {
                LightEffect = params.LightEffect,
                LightEffectBone = params.LightEffectBone,
                GameplayLight = params.GameplayLight,
                GameplayLightRadius = params.GameplayLightRadius,
                GamplayLightSharpness = params.GameplayLightSharpness,
                GameplayLightOffsetFallback = params.GameplayLightOffsetFallback,
                LightOnSound = params.LightOnSound,
                LightOffSound = params.LightOffSound,
                StartLit = params.StartLit,
                GameplayLightPointLightVerticalLimit = params.GameplayLightPointLightVerticalLimit
            },
            inputs = {
                TurnOn = {outputs.TurnOnInt},
                TurnOff = {outputs.TurnOffInt},
                Toggle = {outputs.ToggleInt},
                ChangeVFX = { outputs.ChangeVFXInt }
            },
            outputs = {
                On = {inputs.OnInt},
                Off= {inputs.OffInt}
            }
        }

        socketEvents.TurnOn = function(ev)
            TriggerOutput(outputs.TurnOnInt, ev.Object, ev.Param)
        end

        socketEvents.TurnOff = function(ev)
            TriggerOutput(outputs.TurnOffInt, ev.Object, ev.Param)
        end

        socketEvents.ChangeVFX = function(ev)
            TriggerOutput(outputs.ChangeVFXInt, ev.Object, ev.Param)
        end

        events.UseStarted = function(ev)
            TriggerOutput(outputs.ToggleInt, ev.User.EntityRef, nil)
        end

        socketEvents.OnInt = function(ev)
            TriggerOutput(outputs.On, ev.Object, ev.Param)
        end

        socketEvents.OffInt = function(ev)
            TriggerOutput(outputs.Off, ev.Object, ev.Param)
        end

    end
    
}