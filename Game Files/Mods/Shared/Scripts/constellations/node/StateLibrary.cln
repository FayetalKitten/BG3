game.states.AnimationStates = State{
    function()

        description = [[Continues to the next Dynamic state when activated, waits for it to be executed, and then proceeds to the
                       next Static state.]]

        --dependencies = {EComponentList.AnimationState} -- not supported yet
        --[[Connects to an AnimationState component, which stores the current animationstate)]]

        params.StateSequence = {type = EParamType.Int, help = [[Sequence of states through which the object goes]], arrayRange = ".."}
        params.DynamicStates = {type = EParamType.Int, help = [[Dynamic states, which should be fast-forwarded when the item is loaded.]], arrayRange = ".."}

        --[[E.g. parameters for levers:
        One state: 1-4-1; 1 dynamic
        Two states: 1-5-3-8-1; 5 & 8 dynamic
        Three states: 1-6-2-7-3-8-1; 6, 7, 8 dynamic

        Similarly applies to anything like e.g. rotating puzzle disks as well.
        Could replace these by strings if that helps legibility.]]
        --

        inputs.Activated = {help = [[Input socket that's triggered when the object is triggered and should transition to the next state]]}

        outputs.NewState = {help = [[Output socket that's triggered when the lever enters one of the static states, i.e. stops moving]]}

        helpers.findStateIndex = function(animationState)
            for i,state in pairs(params.StateSequence) do
                if state == animationState then
                    return i
                end
            end
        end

        helpers.isStateDynamic = function(state)
            for _,foundstate in pairs(params.DynamicStates) do
                if state == foundstate then
                    return true
                end
            end
            return false
        end

        helpers.nextState = function(previousState)
            local index = helpers.findStateIndex(previousState)
            local sequence = params.StateSequence
            if index == #sequence then
                return params.StateSequence[1]
            else
                return params.StateSequence[helpers.findStateIndex(previousState) + 1]
            end
        end

        -- Tries to find the next state of a given type (static or dynamic) and progress the state there.
        -- Returns true if the current state was of the wrong type.
        helpers.nextTypedState = function(dynamic)
            local wantedState = me.Blackboard.GetFact("Cnst.AnimationState.WantedState")
            wantedState = helpers.nextState(wantedState) --Move to one state further.
            while helpers.isStateDynamic(wantedState) ~= dynamic do
                wantedState = helpers.nextState(wantedState) -- If this state isn't right, go to next state.
            end
            me.Blackboard.SetFact("Cnst.AnimationState.WantedState", wantedState)
            me.Blackboard.SetFact("Cnst.AnimationState.CurrentState", helpers.nextState(me.Blackboard.GetFact("Cnst.AnimationState.CurrentState")))
            SetAnimationEvent(me, "SetState", me.Blackboard.GetFact("Cnst.AnimationState.CurrentState"))
            --Start the next state. If it's the right type, at the animation event handler, it will match the wanted state.
            --Otherwise, it will simply continue.
        end

        -- On Load, if in dynamic state, set the state to the next one.
        -- If not in a dynamic state, force animation state to current wanted state.
        self.OnLoaded = function()
            if me.Blackboard.GetFact("Cnst.AnimationState.CurrentState") == nil then
                me.Blackboard.SetFact("Cnst.AnimationState.CurrentState", params.StateSequence[1])
                me.Blackboard.SetFact("Cnst.AnimationState.WantedState", params.StateSequence[1])
            end
        end

        socketEvents.Activated = function(ev)
            --local animationState = me.AnimationState.State -- not supported yet
            helpers.nextTypedState(false) -- Move to next static state after the current, passing through any events.
        end

        -- Dynamic states (4 - 8) finish, at which point the script transitions, both internally and in Genome, to the next state,
        -- and sends the fitting event.
        events.AnimationEvent = function(ev)
            if ev.EventName == "stateEnded" then
                local currentState = me.Blackboard.GetFact("Cnst.AnimationState.CurrentState")
                local wantedState = me.Blackboard.GetFact("Cnst.AnimationState.WantedState")
                --code re-sends an event when we load savegames, make sure we were actually waiting for something
                if wantedState and wantedState ~= currentState then
                    local nextState = helpers.nextState(currentState)
                    me.Blackboard.SetFact("Cnst.AnimationState.CurrentState", nextState)

                    if not helpers.isStateDynamic(nextState) then
                        TriggerOutput(outputs.NewState, nil)
                    end

                    if nextState ~= wantedState then
                        SetAnimationEvent(me, "SetState", nextState) --If you're not where you need to be, continue to the next.
                    end
                end
            end
        end

    end
}

game.states.LogicGate_OR = State{
    function()

        description = [[Sends an event if either of the 'on' events have arrived.
                        Either of the 'off' events closes the gate until the corresponding 'on' has arrived.]]

        params.StartOn1 = {type = EParamType.Bool, default = false, help = [[Does the first object start on?]]}
        params.StartOn2 = {type = EParamType.Bool, default = false, help = [[Does the second object start on?]]}

        inputs.On1 = {}
        inputs.On2 = {}
        inputs.Off1 = {}
        inputs.Off2 = {}
        outputs.On = {}
        outputs.Off = {}

        self.OnInit = function(ev)
            if me.Blackboard.GetFact("Cnst.LogicGate_OR.Input1On") == nil then
                me.Blackboard.SetFact("Cnst.LogicGate_OR.Input1On", params.StartOn1 and 1 or 0)
                me.Blackboard.SetFact("Cnst.LogicGate_OR.Input2On", params.StartOn2 and 1 or 0)
            end
        end

        socketEvents.On1 = function(ev)
            me.Blackboard.SetFact("Cnst.LogicGate_OR.Input1On", 1)
            TriggerOutput(outputs.On, ev.Object, ev.Param)
        end

        socketEvents.On2 = function(ev)
            me.Blackboard.SetFact("Cnst.LogicGate_OR.Input2On", 1)
            TriggerOutput(outputs.On, ev.Object, ev.Param)
        end

        socketEvents.Off1 = function(ev)
            me.Blackboard.SetFact("Cnst.LogicGate_OR.Input1On", 0)
            if me.Blackboard.GetFact("Cnst.LogicGate_OR.Input2On") ~= 1 then
                TriggerOutput(outputs.Off, ev.Object, ev.Param)
            end
        end

        socketEvents.Off2 = function(ev)
            me.Blackboard.SetFact("Cnst.LogicGate_OR.Input2On", 0)
            if me.Blackboard.GetFact("Cnst.LogicGate_OR.Input1On") ~= 1 then
                TriggerOutput(outputs.Off, ev.Object, ev.Param)
            end
        end

    end
}

game.states.LogicGate_AND = State{
    function()

        description = [[Sends an event if both of the 'on' events have arrived.
                        Either of the 'off' events closes the gate until the corresponding 'on' has arrived.]]

        params.StartOn1 = {type = EParamType.Bool, default = false, help = [[Does the first object start on?]]}
        params.StartOn2 = {type = EParamType.Bool, default = false, help = [[Does the second object start on?]]}

        inputs.On1 = {}
        inputs.On2 = {}
        inputs.Off1 = {}
        inputs.Off2 = {}
        outputs.On = {}
        outputs.Off = {}

        self.OnInit = function(ev)
            if me.Blackboard.GetFact("Cnst.LogicGate_OR.Input1On") == nil then
                me.Blackboard.SetFact("Cnst.LogicGate_OR.Input1On", params.StartOn1 and 1 or 0)
                me.Blackboard.SetFact("Cnst.LogicGate_OR.Input2On", params.StartOn2 and 1 or 0)
            end
        end

        socketEvents.On1 = function(ev)
            me.Blackboard.SetFact("Cnst.LogicGate_OR.Input1On", 1)
            if me.Blackboard.GetFact("Cnst.LogicGate_OR.Input2On") == 1 then
                TriggerOutput(outputs.On, ev.Object)
            end
        end

        socketEvents.On2 = function(ev)
            me.Blackboard.SetFact("Cnst.LogicGate_OR.Input2On", 1)
            if me.Blackboard.GetFact("Cnst.LogicGate_OR.Input1On") == 1 then
                TriggerOutput(outputs.On, ev.Object)
            end
        end

        socketEvents.Off1 = function(ev)
            me.Blackboard.SetFact("Cnst.LogicGate_OR.Input1On", 0)
            TriggerOutput(outputs.Off, ev.Object)
        end

        socketEvents.Off2 = function(ev)
            me.Blackboard.SetFact("Cnst.LogicGate_OR.Input2On", 0)
            TriggerOutput(outputs.Off, ev.Object)
        end

    end
}

game.states.Timer = State{
    function()

        description = "Generic timer that can be turned on and off."

        params.StartActive = {type = EParamType.Bool, default = false, help = [[Does the object timer start running?]]}
        params.TickLength = {type = EParamType.Number, default = 6.0, help = [[Timer step duration.]]}
        params.Repeats = {type = EParamType.Int, default = 0.0, help = [[How often this timer repeats]]}
        params.TargetEntity = { type = EParamType.String, required = true, help = "Object to which the timer is attached."}

        inputs.Start = {help = "Start Timer"}
        inputs.Stop = {help = "Stop Timer"}

        outputs.Tick = {help = "Timer Tick"}

        helpers.Init = function()
            if me.Blackboard.GetFact("TargetEntity") == nil then
                if params.TargetEntity == "me" then
                    me.Blackboard.SetFact("TargetEntity", me)
                else
                    me.Blackboard.SetFact("TargetEntity",FindEntity(params.TargetEntity))
                end
            end
            me.Blackboard.SetFact("Cnst.Timer.TimerOn", params.StartActive and 1 or 0)
            if params.StartActive then
                StartTimer(me, "Cnst.Timer.GenTrapTimer", params.TickLength, params.Repeats)
                if IsInvolvedInFTB(me.Blackboard.GetFact("TargetEntity")) then
                    PauseTimer(me, "Cnst.Timer.GenTrapTimer")
                end
            end
        end

        self.OnEditorChanges = function()
            local timerWasOn = me.Blackboard.GetFact("Cnst.Timer.TimerOn")

            -- always stop/restart even if it was running already and needs to keep running
            -- to handle changes to the ticklength/repeats parameters
            StopTimer(me, "Cnst.Timer.GenTrapTimer")
            me.Blackboard.SetFact("Cnst.Timer.TimerOn", params.StartActive and 1 or 0)
            if params.StartActive and
               timerWasOn then
                StartTimer(me, "Cnst.Timer.GenTrapTimer", params.TickLength, params.Repeats)
            end
        end

        self.OnInit = function()
            if me.Blackboard.GetFact("Cnst.Timer.TimerOn") ~= nil then
                return
            end

            helpers.Init()
        end

        events.EnteredForceTurnBased = function(ev)
            if me.Blackboard.GetFact("Cnst.Timer.TimerOn") == 1 then
                PauseTimer(me, "Cnst.Timer.GenTrapTimer")
            end
        end

        events.LeftForceTurnBased = function(ev)
            if me.Blackboard.GetFact("Cnst.Timer.TimerOn") == 1 then
                if me.Blackboard.GetFact("Cnst.Timer.TimerStartBlockedByFTB") == 1 then
                    StartTimer(me, "Cnst.Timer.GenTrapTimer", params.TickLength, params.Repeats)
                else
                    UnpauseTimer(me, "Cnst.Timer.GenTrapTimer")
                end
            end
            me.Blackboard.ClearFact("Cnst.Timer.TimerStartBlockedByFTB")
        end

        events.ForceTurnBasedPartyTurnEnded  = function(ev)
            if me.Blackboard.GetFact("TargetEntity") == nil then
            else
                if IsInvolvedInFTB(me.Blackboard.GetFact("TargetEntity")) and
                    ev.FTBZoneId == me.Blackboard.GetFact("TargetEntity").FTBZoneId and
                me.Blackboard.GetFact("Cnst.Timer.TimerOn") == 1 then
                    TriggerOutput(outputs.Tick, nil)
                end
            end
        end

        socketEvents.Start = function(ev)
            if not IsInvolvedInFTB(me.Blackboard.GetFact("TargetEntity")) then
                if me.Blackboard.GetFact("Cnst.Timer.TimerOn") ~= 1 then
                    me.Blackboard.SetFact("Cnst.Timer.TimerOn", 1)
                    StartTimer(me, "Cnst.Timer.GenTrapTimer", params.TickLength, params.Repeats)
                else
                    StopTimer(me, "Cnst.Timer.GenTrapTimer")
                    StartTimer(me, "Cnst.Timer.GenTrapTimer", params.TickLength, params.Repeats)
                end
            else
                me.Blackboard.SetFact("Cnst.Timer.TimerOn", 1)
                me.Blackboard.SetFact("Cnst.Timer.TimerStartBlockedByFTB", 1)
            end
        end

        socketEvents.Stop = function(ev)
            me.Blackboard.ClearFact("Cnst.Timer.TimerStartBlockedByFTB")
            if me.Blackboard.GetFact("Cnst.Timer.TimerOn") == 1 then
                StopTimer(me, "Cnst.Timer.GenTrapTimer")
                me.Blackboard.SetFact("Cnst.Timer.TimerOn", 0)
            elseif me.Blackboard.GetFact("Cnst.Timer.TimerOn") == nil then
                me.Blackboard.SetFact("Cnst.Timer.TimerOn", 0)
            end
        end

        events.TimerFinished = function(ev)
            if ev.TimerName == "Cnst.Timer.GenTrapTimer" then
                TriggerOutput(outputs.Tick, nil)
            end
        end

    end
}

game.states.StoryInteractionFilter = State{
    function()
        description = [[Enable/distable blocking use through story]]

        params.StartUseEnabled = {
            type = EParamType.Bool,
            default = true,
            help = "Does the item's use start enabled?"
        }

        inputs.EnableStoryItemUse = {help = [[Allow item use from story]]}
        inputs.DisableStoryItemUse = {help = [[Block item use from story]]}

        -- Mainly to centralise the sockets related to this functionality,
        -- since the input just triggers the output. Also allows hooking up
        -- this socket to the same socket handler as that for other blocked/
        -- failed uses where appropriate (non-trapped entities).
        inputs.UseBlockedFromStory = {help = [[Item use was blocked from story]]}
        outputs.UseBlockedFromStory = {help = [[Item use was blocked from story]]}

        helpers.UpdateStoryBlockTag = function(enabled)
            local tag = Tag("BLOCK_USE_FROM_CONSTELLATION_89a63758-d622-41cd-81f9-baceffc12618")
            if enabled then
                RemoveTag(me, tag)
            else
                AddTag(me, tag)
            end
        end

        self.OnEditorChanges = function()
            me.Blackboard.ClearFact("Cnst.StoryInteractionFilter.Inited")
        end

        self.OnInit = function()
            if me.Blackboard.GetFact("Cnst.StoryInteractionFilter.Inited") == nil then
                me.Blackboard.SetFact("Cnst.StoryInteractionFilter.Inited", 1)
                helpers.UpdateStoryBlockTag(params.StartUseEnabled)
            end
        end

        socketEvents.EnableStoryItemUse = function(ev)
            helpers.UpdateStoryBlockTag(true)
        end

        socketEvents.DisableStoryItemUse = function(ev)
            helpers.UpdateStoryBlockTag(false)
        end

        socketEvents.UseBlockedFromStory = function(ev)
            TriggerOutput(outputs.UseBlockedFromStory, ev.Object, ev.Param)
        end

    end
}


game.states.Dummy = State{
    function()

        description = [[Does nothing.]]

    end
}