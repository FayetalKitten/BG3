game.states.Helper_Continue = State{
    function()

        description = [[Just sends the event on as it came in. For organisational purposes.]]

        inputs.In = {}
        outputs.Out = {}

        socketEvents.In = function(ev)
            TriggerOutput(outputs.Out, ev.Object, ev.Param)
        end

    end
}

game.states.Helper_SetParameter_Bool = State{
    function()

        description = [[Overrides the Param of the socket event with the provided value]]

        params.Value = {type = EParamType.Bool, required=true, help=[[
            Value with which the param is overridden.
        ]]}

        inputs.In = {}
        outputs.Out = {}

        socketEvents.In = function(ev)
            TriggerOutput(outputs.Out, ev.Object, params.Value)
        end

    end
}

game.states.Helper_ObjectParameterSwap = State{
    function()

        description = [[Swaps Object and Parameter]]


        inputs.In = {}
        outputs.Out = {}

        socketEvents.In = function(ev)
            TriggerOutput(outputs.Out, ev.Param, ev.Object)
        end

    end
}

game.states.Helper_SetParameter_String = State{
    function()

        description = [[Overrides the Param of the socket event with the provided value]]

        params.Value = {type = EParamType.String, required=true, help=[[
            Value with which the param is overridden.
        ]]}

        inputs.In = {}
        outputs.Out = {}

        socketEvents.In = function(ev)
            TriggerOutput(outputs.Out, ev.Object, params.Value)
        end

    end
}

game.states.Helper_Toggle = State{
    function()

        description = [[Toggles a value on or off]]

        params.StartValue = {type = EParamType.Bool, required=true, help=[[
            Start value.
        ]]}

        self.OnInit = function()
            if not me.Blackboard.GetFact("Cnst.Toggle.Value") then
                me.Blackboard.SetFact("Cnst.Toggle.Value", params.StartValue and 1 or 0)
            end
        end

        self.OnEditorChanges = function()
            me.Blackboard.ClearFact("Cnst.Toggle.Value")
        end

        inputs.Toggle = {}
        outputs.On = {}
        outputs.Off = {}

        socketEvents.Toggle = function(ev)
            local currentValue = me.Blackboard.GetFact("Cnst.Toggle.Value")
            local newValue = currentValue == 1 and 0 or 1
            me.Blackboard.SetFact("Cnst.Toggle.Value", newValue)

            if newValue == 1 then
                TriggerOutput(outputs.On, ev.Object, ev.Param)
            else
                TriggerOutput(outputs.Off, ev.Object, ev.Param)
            end
        end

    end
}

game.states.Helper_CompareParameter_Number = State{
    function()

        description = [[Compares the Param of the socket event with the provided value]]

        params.Value = {type = EParamType.Number, required=true, help=[[
            Value with which the param is compared.
        ]]}

        inputs.In = {}
        outputs.Equal = {}
        outputs.LessThan = {}
        outputs.GreaterThan = {}

        socketEvents.In = function(ev)
            if type(ev.Param) == "number" then
                if ev.Param == params.Value then
                    TriggerOutput(outputs.Equal, ev.Object, ev.Param)
                elseif ev.Param < params.Value then
                    TriggerOutput(outputs.LessThan, ev.Object, ev.Param)
                else
                    TriggerOutput(outputs.GreaterThan, ev.Object, ev.Param)
                end
            else
                DebugLogCritical("Helper_CompareParameter_Number '[1]' (GUID [2]) got socket event with non-number parameter", me.Name, me.UUID.String)
            end
        end

    end
}

game.states.Helper_CompareParameter_Bool = State{
    function()

        description = [[Compares the Param of the socket event with the provided value]]

        params.Value = {type = EParamType.Bool, required=true, help=[[
            Value with which the param is compared.
        ]]}

        inputs.In = {}
        outputs.Equal = {}
        outputs.NotEqual = {}

        socketEvents.In = function(ev)
            if type(ev.Param) == "boolean" then
                if ev.Param == params.Value then
                    TriggerOutput(outputs.Equal, ev.Object, ev.Param)
                else
                    TriggerOutput(outputs.NotEqual, ev.Object, ev.Param)
                end
            else
                DebugLogCritical("Helper_CompareParameter_Bool '[1]' (GUID [2]) got socket event with non-bool parameter", me.Name, me.UUID.String)
            end
        end

    end
}


game.states.Helper_EntityEvent_In = State{
    function()

        description = [[Catches an entity event & sends a Socket event]]

        params.EventName = {type = EParamType.String, required=true, help=[[
            Name of the event
        ]]}

        outputs.EventSent = {}

        events.EntityEvent = function(e)
            if e.Event == params.EventName and
                e.TargetEntity == me then
                if e.Params[2] ~= nil then
                    TriggerOutput(outputs.EventSent, nil, e.Params[2])
                else
                    TriggerOutput(outputs.EventSent, nil)
                    end
                end
            end

    end
}

game.states.Helper_EntityEvent_Out = State{
    function()

        description = [[Sends an entity event with the Parameter, if any, of the incoming socket event]]

        params.EventName = {type = EParamType.String, required=true, help=[[
            Name of the event
        ]]}

        inputs.In = {}

        socketEvents.In = function(ev)
            if ev.Param == nil then
                SetUnicastEntityEvent(me, params.EventName)
            else
                SetUnicastEntityEvent(me, params.EventName, Entity(ev.Param))
            end
        end


    end
}


game.states.Helper_GlobalFlag = State{
    function()

        description = [[Catches the setting & clearing of a global flag]]

        params.FlagName = {type = EParamType.String, required=true, help=[[
            Name of the Flag
        ]]}

        outputs.FlagSet = {}
        outputs.FlagCleared = {}

        local flagGuid

        self.OnInit = function(e)
            if me.Blackboard.GetFact("Cnst.GlobalFlag.LastSent") == nil then
                me.Blackboard.SetFact("Cnst.GlobalFlag.LastSent", 0)
            end
            if not flagGuid then
                flagGuid = Flag(params.FlagName).Guid
            end
            if me.Blackboard.GetFact("Cnst.GlobalFlag.LastSent") == 0 and
               GetFlag(Flag(params.FlagName)) == true
            then
                TriggerOutput(outputs.FlagSet, nil)
                me.Blackboard.SetFact("Cnst.GlobalFlag.LastSent", 1)
            elseif me.Blackboard.GetFact("Cnst.GlobalFlag.LastSent") == 1 and
                   GetFlag(Flag(params.FlagName)) == false
            then
               TriggerOutput(outputs.FlagCleared, nil)
               me.Blackboard.SetFact("Cnst.GlobalFlag.LastSent", 0)
            end
        end

        events.FlagSet = function(e)
            if not flagGuid then
                flagGuid = Flag(params.FlagName).Guid
            end
            if e.Flag == flagGuid then
                TriggerOutput(outputs.FlagSet, nil)
                me.Blackboard.SetFact("Cnst.GlobalFlag.LastSent", 1)
            end
        end

        events.FlagCleared = function(e)
            if not flagGuid then
                flagGuid = Flag(params.FlagName).Guid
            end
            if e.Flag == flagGuid then
                TriggerOutput(outputs.FlagCleared, nil)
                me.Blackboard.SetFact("Cnst.GlobalFlag.LastSent", 0)
            end
        end

    end
}

game.states.Helper_Sequence = State{
    function()
        description = [[Check whether a number of steps are triggered in sequence]]

        params.StepSequence =
        {
            type = EParamType.Int,
            required = true,
            arrayRange = "1..",
            help = [[The sequence in which the StepX sockets need to be triggered (repeats are allowed)]]
        }

        params.StartEnabled =
        {
            type = EParamType.Bool,
            default = true,
            help = [[Whether or not you can start triggering sequence steps from the start.]]
        }

        params.ResetOnFailure =
        {
            type = EParamType.Bool,
            default = true,
            help = [[Reset the sequence when an error is made, otherwise stay on the current step number]]
        }

        params.DisableOnSuccess =
        {
            type = EParamType.Bool,
            default = true,
            help = [[Disable further checks once the correct sequence has been triggered once.
                     Otherwise the sequence will reset on completion.]]
        }

        inputs.Reset = { help = [[Reset the sequence to the beginning, failure does not get triggered]] }
        inputs.ResetWithFailure = { help = [[Reset the sequence, failure gets triggered]] }
        inputs.Enable = { help = [[Allow inputs to trigger the logic again]] }
        inputs.Disable = { help = [[Prevent further inputs from triggering any logic]] }

        outputs.Failure = { help = [[Input sockets got triggered in the wrong order, event parameter = failed step number]] }
        outputs.Success = { help = [[All required input sockets got triggered in the correct order]] }
        outputs.StepCompleted = { help = [[Successfully triggered a step, event parameter = step number]]}

        inputs.Step1 = { help = [[Trigger Step 1 in the sequence]] }
        inputs.Step2 = { help = [[Trigger Step 2 in the sequence]] }
        inputs.Step3 = { help = [[Trigger Step 3 in the sequence]] }
        inputs.Step4 = { help = [[Trigger Step 4 in the sequence]] }
        inputs.Step5 = { help = [[Trigger Step 5 in the sequence]] }
        inputs.Step6 = { help = [[Trigger Step 6 in the sequence]] }
        inputs.Step7 = { help = [[Trigger Step 7 in the sequence]] }
        inputs.Step8 = { help = [[Trigger Step 8 in the sequence]] }
        inputs.Step9 = { help = [[Trigger Step 9 in the sequence]] }

        helpers.StepTriggered = function(stepNumber, ev)
            -- Disabled -> do nothing
            if me.Blackboard.GetFact("Cnst.CheckedSequence.Disabled") ~= nil then
                return
            end

            local currentIndex = me.Blackboard.GetFact("Cnst.CheckedSequence.Index")

            if params.StepSequence[currentIndex] ~= stepNumber then
                -- wrong step triggered
                TriggerOutput(outputs.Failure, ev.Object, stepNumber)

                if params.ResetOnFailure then
                    me.Blackboard.SetFact("Cnst.CheckedSequence.Index", 1)
                end

                -- otherwise stay on current step number
            else
                -- correct step triggered
                TriggerOutput(outputs.StepCompleted, ev.Object, stepNumber)

                if currentIndex == #params.StepSequence then
                    -- end of sequence
                    TriggerOutput(outputs.Success, ev.Object, ev.Param)

                    if params.DisableOnSuccess then
                        me.Blackboard.SetFact("Cnst.CheckedSequence.Disabled", 1)
                    end

                    -- always set index back to the start (can be re-enabled later
                    -- even if disabled above)
                    me.Blackboard.SetFact("Cnst.CheckedSequence.Index", 1)
                else
                    -- next step
                    me.Blackboard.SetFact("Cnst.CheckedSequence.Index", currentIndex + 1)
                end
            end
        end

        self.OnInit = function()
            if me.Blackboard.GetFact("Cnst.CheckedSequence.Index") == nil then
                me.Blackboard.SetFact("Cnst.CheckedSequence.Index", 1)
                if not params.StartEnabled then
                    me.Blackboard.SetFact("Cnst.CheckedSequence.Disabled", 1)
                end
            end
        end

        socketEvents.Reset = function(ev)
            me.Blackboard.SetFact("Cnst.CheckedSequence.Index", 1)
        end

        socketEvents.ResetWithFailure = function(ev)
            me.Blackboard.SetFact("Cnst.CheckedSequence.Index", 1)
            TriggerOutput(outputs.Failure, ev.Object, ev.Param)
        end

        socketEvents.Disable = function(ev)
            me.Blackboard.SetFact("Cnst.CheckedSequence.Disabled", 1)
        end

        socketEvents.Enable = function(ev)
            me.Blackboard.ClearFact("Cnst.CheckedSequence.Disabled")
        end

        socketEvents.Step1 = function(ev)
            helpers.StepTriggered(1, ev)
        end

        socketEvents.Step2 = function(ev)
            helpers.StepTriggered(2, ev)
        end

        socketEvents.Step3 = function(ev)
            helpers.StepTriggered(3, ev)
        end

        socketEvents.Step4 = function(ev)
            helpers.StepTriggered(4, ev)
        end

        socketEvents.Step5 = function(ev)
            helpers.StepTriggered(5, ev)
        end

        socketEvents.Step6 = function(ev)
            helpers.StepTriggered(6, ev)
        end

        socketEvents.Step7 = function(ev)
            helpers.StepTriggered(7, ev)
        end

        socketEvents.Step8 = function(ev)
            helpers.StepTriggered(8, ev)
        end

        socketEvents.Step9 = function(ev)
            helpers.StepTriggered(9, ev)
        end

    end
}